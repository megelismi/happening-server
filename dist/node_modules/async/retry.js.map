{"version":3,"sources":["../../../node_modules/async/retry.js"],"names":["Object","defineProperty","exports","value","default","retry","_noop","require","_noop2","_interopRequireDefault","_constant","_constant2","obj","__esModule","opts","task","callback","DEFAULT_TIMES","DEFAULT_INTERVAL","options","times","intervalFunc","parseTimes","acc","t","interval","errorFilter","Error","arguments","length","attempt","retryAttempt","err","setTimeout","apply","module"],"mappings":"AAAA;;;;AAEAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AACzCC,WAAO;AADkC,CAA7C;AAGAD,QAAQE,OAAR,GAAkBC,KAAlB;;AAEA,IAAIC,QAAQC,QAAQ,aAAR,CAAZ;;AAEA,IAAIC,SAASC,uBAAuBH,KAAvB,CAAb;;AAEA,IAAII,YAAYH,QAAQ,iBAAR,CAAhB;;AAEA,IAAII,aAAaF,uBAAuBC,SAAvB,CAAjB;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;AAAE,WAAOA,OAAOA,IAAIC,UAAX,GAAwBD,GAAxB,GAA8B,EAAER,SAASQ,GAAX,EAArC;AAAwD;;AAE/F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFA,SAASP,KAAT,CAAeS,IAAf,EAAqBC,IAArB,EAA2BC,QAA3B,EAAqC;AACjC,QAAIC,gBAAgB,CAApB;AACA,QAAIC,mBAAmB,CAAvB;;AAEA,QAAIC,UAAU;AACVC,eAAOH,aADG;AAEVI,sBAAc,CAAC,GAAGV,WAAWP,OAAf,EAAwBc,gBAAxB;AAFJ,KAAd;;AAKA,aAASI,UAAT,CAAoBC,GAApB,EAAyBC,CAAzB,EAA4B;AACxB,YAAI,QAAOA,CAAP,yCAAOA,CAAP,OAAa,QAAjB,EAA2B;AACvBD,gBAAIH,KAAJ,GAAY,CAACI,EAAEJ,KAAH,IAAYH,aAAxB;;AAEAM,gBAAIF,YAAJ,GAAmB,OAAOG,EAAEC,QAAT,KAAsB,UAAtB,GAAmCD,EAAEC,QAArC,GAAgD,CAAC,GAAGd,WAAWP,OAAf,EAAwB,CAACoB,EAAEC,QAAH,IAAeP,gBAAvC,CAAnE;;AAEAK,gBAAIG,WAAJ,GAAkBF,EAAEE,WAApB;AACH,SAND,MAMO,IAAI,OAAOF,CAAP,KAAa,QAAb,IAAyB,OAAOA,CAAP,KAAa,QAA1C,EAAoD;AACvDD,gBAAIH,KAAJ,GAAY,CAACI,CAAD,IAAMP,aAAlB;AACH,SAFM,MAEA;AACH,kBAAM,IAAIU,KAAJ,CAAU,mCAAV,CAAN;AACH;AACJ;;AAED,QAAIC,UAAUC,MAAV,GAAmB,CAAnB,IAAwB,OAAOf,IAAP,KAAgB,UAA5C,EAAwD;AACpDE,mBAAWD,QAAQP,OAAOJ,OAA1B;AACAW,eAAOD,IAAP;AACH,KAHD,MAGO;AACHQ,mBAAWH,OAAX,EAAoBL,IAApB;AACAE,mBAAWA,YAAYR,OAAOJ,OAA9B;AACH;;AAED,QAAI,OAAOW,IAAP,KAAgB,UAApB,EAAgC;AAC5B,cAAM,IAAIY,KAAJ,CAAU,mCAAV,CAAN;AACH;;AAED,QAAIG,UAAU,CAAd;AACA,aAASC,YAAT,GAAwB;AACpBhB,aAAK,UAAUiB,GAAV,EAAe;AAChB,gBAAIA,OAAOF,YAAYX,QAAQC,KAA3B,KAAqC,OAAOD,QAAQO,WAAf,IAA8B,UAA9B,IAA4CP,QAAQO,WAAR,CAAoBM,GAApB,CAAjF,CAAJ,EAAgH;AAC5GC,2BAAWF,YAAX,EAAyBZ,QAAQE,YAAR,CAAqBS,OAArB,CAAzB;AACH,aAFD,MAEO;AACHd,yBAASkB,KAAT,CAAe,IAAf,EAAqBN,SAArB;AACH;AACJ,SAND;AAOH;;AAEDG;AACH;AACDI,OAAOjC,OAAP,GAAiBA,QAAQ,SAAR,CAAjB","file":"retry.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = retry;\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _constant = require('lodash/constant');\n\nvar _constant2 = _interopRequireDefault(_constant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {Function} task - A function which receives two arguments: (1) a\n * `callback(err, result)` which must be called when finished, passing `err`\n * (which can be `null`) and the `result` of the function's execution, and (2)\n * a `results` object, containing the results of the previously executed\n * functions (if nested inside another control flow). Invoked with\n * (callback, results).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // It can also be embedded within other control flow functions to retry\n * // individual methods that are not as reliable, like this:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retry(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: (0, _constant2.default)(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : (0, _constant2.default)(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || _noop2.default;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || _noop2.default;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var attempt = 1;\n    function retryAttempt() {\n        task(function (err) {\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\nmodule.exports = exports['default'];"]}