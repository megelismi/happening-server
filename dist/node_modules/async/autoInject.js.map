{"version":3,"sources":["../../../node_modules/async/autoInject.js"],"names":["Object","defineProperty","exports","value","default","autoInject","_auto","require","_auto2","_interopRequireDefault","_baseForOwn","_baseForOwn2","_arrayMap","_arrayMap2","_isArray","_isArray2","_trim","_trim2","obj","__esModule","FN_ARGS","FN_ARG_SPLIT","FN_ARG","STRIP_COMMENTS","parseParams","func","toString","replace","match","split","map","arg","tasks","callback","newTasks","taskFn","key","params","slice","length","concat","newTask","Error","pop","results","taskCb","newArgs","name","push","apply","module"],"mappings":"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","file":"autoInject.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = autoInject;\n\nvar _auto = require('./auto');\n\nvar _auto2 = _interopRequireDefault(_auto);\n\nvar _baseForOwn = require('lodash/_baseForOwn');\n\nvar _baseForOwn2 = _interopRequireDefault(_baseForOwn);\n\nvar _arrayMap = require('lodash/_arrayMap');\n\nvar _arrayMap2 = _interopRequireDefault(_arrayMap);\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _trim = require('lodash/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FN_ARGS = /^(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg) {\n        return (0, _trim2.default)(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is a function of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    (0, _baseForOwn2.default)(tasks, function (taskFn, key) {\n        var params;\n\n        if ((0, _isArray2.default)(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (taskFn.length === 1) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = (0, _arrayMap2.default)(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            taskFn.apply(null, newArgs);\n        }\n    });\n\n    (0, _auto2.default)(newTasks, callback);\n}\nmodule.exports = exports['default'];"]}