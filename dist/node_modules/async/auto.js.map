{"version":3,"sources":["../../../node_modules/async/auto.js"],"names":["Object","defineProperty","exports","value","default","tasks","concurrency","callback","_once2","_noop2","keys","_keys2","numTasks","length","results","runningTasks","hasError","listeners","readyTasks","readyToCheck","uncheckedDependencies","_baseForOwn2","task","key","_isArray2","enqueueTask","push","dependencies","slice","remainingDependencies","_arrayEach2","dependencyName","Error","join","addListener","checkForDeadlocks","processQueue","runTask","run","shift","taskName","fn","taskListeners","taskComplete","taskCallback","_onlyOnce2","_rest2","err","args","safeResults","val","rkey","taskFn","currentTask","counter","pop","getDependents","dependent","result","_baseIndexOf2","_arrayEach","require","_interopRequireDefault","_baseForOwn","_baseIndexOf","_isArray","_keys","_noop","_rest","_once","_onlyOnce","obj","__esModule","module"],"mappings":"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","file":"auto.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = (0, _once2.default)(callback || _noop2.default);\n    var keys = (0, _keys2.default)(tasks);\n    var numTasks = keys.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = {};\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    (0, _baseForOwn2.default)(tasks, function (task, key) {\n        if (!(0, _isArray2.default)(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        (0, _arrayEach2.default)(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        (0, _arrayEach2.default)(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = (0, _onlyOnce2.default)((0, _rest2.default)(function (err, args) {\n            runningTasks--;\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            if (err) {\n                var safeResults = {};\n                (0, _baseForOwn2.default)(results, function (val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = args;\n                hasError = true;\n                listeners = [];\n\n                callback(err, safeResults);\n            } else {\n                results[key] = args;\n                taskComplete(key);\n            }\n        }));\n\n        runningTasks++;\n        var taskFn = task[task.length - 1];\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            (0, _arrayEach2.default)(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        (0, _baseForOwn2.default)(tasks, function (task, key) {\n            if ((0, _isArray2.default)(task) && (0, _baseIndexOf2.default)(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\nvar _arrayEach = require('lodash/_arrayEach');\n\nvar _arrayEach2 = _interopRequireDefault(_arrayEach);\n\nvar _baseForOwn = require('lodash/_baseForOwn');\n\nvar _baseForOwn2 = _interopRequireDefault(_baseForOwn);\n\nvar _baseIndexOf = require('lodash/_baseIndexOf');\n\nvar _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _keys = require('lodash/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _rest = require('./internal/rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _once = require('./internal/once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/**\n * Determines the best order for running the functions in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the functions pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * Functions also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the function itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */"]}